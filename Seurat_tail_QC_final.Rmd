---
title: "Seurat_tail_initial_final"
output: html_document
date: "2025-07-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Libraries
```{r}
library(ggplot2)
library(dplyr)
library(monocle3)
library(Seurat)
library(DoubletFinder)
```

# Special install code:
remotes::install_github('chris-mcginnis-ucsf/DoubletFinder', force = TRUE)

# To reload, if you've already run this file
```{r}
tail <- LoadSeuratRds(file = "tail_final.rds")
```

## Load Data- we're starting back at the cellranger filtered output (so it's been subsampled)
```{r}
tail <- Read10X(data.dir = "C:/Users/sprou/Downloads/filtered_feature_bc_matrix")
tail <- CreateSeuratObject(counts = tail, min.cells = 3, min.features = 200, names.field = 2, names.delim = "-")

tail$Sample <- dplyr::recode(tail$orig.ident,
                            "1" = "0dpa",
                            "2" = "7dpa",
                            "3" = "un0dpa",
                            "4" = "un1dpa",
                            "5" = "1dpa",
                            "6" = "un7dpa",
                            "7" = "3dpa",
                            "8" = "un3dpa")
```

## Filtering and QC
```{r}
# Mitochondrial genes
tail[["percent.mt"]] <- PercentageFeatureSet(tail, features = c("nd1", "nd2", "cox2", "ATP8", "ATP6", "cox3", "nd3", "nd4l", "nd4", "nd5", "cytb"))

# Ribosomal genes
ribosomal_proteins <- c("rpl3", "rpl4", "rpl5", "rpl6", "rpl7", "rpl8", "rpl9", "rpl10", "rpl7a", "rpl10a", "rpl11", "rpl12", "rpl13", "rpl13", "rpl14", "rpl15", "rpl17", "rpl18", "rpl18a", "rpl19", "rpl21", "rpl22", "rpl23", "rpl23a", "rpl24", "rpl27", "rpl27a", "rpl28", "rpl29", "rpl30", "rpl31", "rpl32", "rpl34", "rpl35", "rpl35a", "rpl36", "rpl36a", "rpl37", "rpl37a", "rpl38", "rpl39", "rps2", "rps3", "rps3a", "rps5", "rps6", "rps7", "rps8", "rps9", "rps10", "rps11", "rps12", "rps13", "rps14", "rps15", "rps15a", "rps16", "rps17", "rps18", "rps19", "rps20", "rps21", "rps22", "rps23", "rps24", "rps25", "rps26", "rps27", "rps28", "rps29", "rplp1", "rplp0", "rpsa", "rps27a", "rpl26", "rpl13a", "rplp2", "rps4x")
tail[["percent.rp"]] <- PercentageFeatureSet(tail, features = ribosomal_proteins)

VlnPlot(tail, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.rp"), ncol = 4, group.by =  "Sample", pt.size = 0)
VlnPlot(tail, features = c("nCount_RNA"), group.by =  "Sample", pt.size = 0)

# Visualize patterns between these QC
FeatureScatter(tail, feature1 = "nCount_RNA", feature2 = "percent.mt", group.by =  "Sample")
FeatureScatter(tail, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by =  "Sample")
FeatureScatter(tail, feature1 = "percent.mt", feature2 = "nFeature_RNA", group.by =  "Sample")
FeatureScatter(tail, feature1 = "percent.rp", feature2 = "percent.mt", group.by =  "Sample")

ggplot(tail[[]]) +
  geom_point(aes(x=nCount_RNA,y=nFeature_RNA,fill=percent.mt > 25),shape=21,alpha=0.4) + 
  theme_classic() +
  scale_x_log10()+
  scale_y_log10()

# Some sources say that cellranger always excludes cells with less than 500 umi but clearly it didn't this time- maybe in this version it doesn't do it automatically
ggplot(tail[[]]) +
  geom_point(aes(x=nCount_RNA,y=nFeature_RNA,fill=nFeature_RNA < 500),shape=21,alpha=0.4) + 
  theme_classic() +
  scale_x_log10()+
  scale_y_log10()

ggplot(tail[[]]) +
  geom_point(aes(x=nCount_RNA,y=nFeature_RNA,fill=Sample),shape=21,alpha=0.4) + 
  theme_classic() +
  scale_x_log10()+
  scale_y_log10()

tail <- subset(tail, subset = nFeature_RNA > 200 & percent.mt < 25) # nFeature_RNA > 200 is standard, other I determined based on plot. See last chunk for how I decided on the nFeature limit- tldr it seemed like there were two clusters made entirely of cells with a low feature count so I went back and decided on a 500 cutoff and reran it
```

# Run it through DoubletFinder
# Good resource for understanding DoubletFinder: https://blaserlab.r-universe.dev/DoubletFinder/doc/readme
# This code was adapted from the github repository of ankita16lawarde/scRNA-Seq_endometriosis
https://github.com/ankita16lawarde/scRNA-Seq_endometriosis/blob/main/data_pre-process-integration_clustering.R

```{r}
tail@meta.data$doublet_finder <- NA

tail_post.split <- SplitObject(tail, split.by = "Sample") # We're actually going to go back to the non-scaled data, since we'll rescale by sample

# loop through samples to find doublets
for (i in 1:length(tail_post.split)) {
  # print the sample we are on
  print(paste0("Sample ",i))
  
  # Pre-process seurat object with standard seurat workflow
  tail.sample <- NormalizeData(tail_post.split[[i]])
  tail.sample <- FindVariableFeatures(tail.sample)
  tail.sample <- ScaleData(tail.sample)
  tail.sample <- RunPCA(tail.sample, nfeatures.print = 10)
  
  # Find significant PCs
  stdv <- tail.sample[["pca"]]@stdev
  sum.stdv <- sum(tail.sample[["pca"]]@stdev)
  percent.stdv <- (stdv / sum.stdv) * 100
  cumulative <- cumsum(percent.stdv)
  co1 <- which(cumulative > 90 & percent.stdv < 5)[1]
  co2 <- sort(which((percent.stdv[1:length(percent.stdv) - 1] - 
                       percent.stdv[2:length(percent.stdv)]) > 0.1), 
              decreasing = T)[1] + 1
  min.pc <- min(co1, co2)
  min.pc
  
  # finish pre-processing
  tail.sample <- RunUMAP(tail.sample, dims = 1:min.pc)
  tail.sample <- FindNeighbors(object = tail.sample, dims = 1:min.pc)              
  tail.sample <- FindClusters(object = tail.sample, resolution = 0.1)
  
  # pK identification (no ground-truth)
  sweep.list <- paramSweep(tail.sample, PCs = 1:min.pc, num.cores = 1)
  sweep.stats <- summarizeSweep(sweep.list)
  bcmvn <- find.pK(sweep.stats)
  
  # Optimal pK is the max of the bomodality coefficent (BCmvn) distribution
  bcmvn.max <- bcmvn[which.max(bcmvn$BCmetric),]
  optimal.pk <- bcmvn.max$pK
  optimal.pk <- as.numeric(levels(optimal.pk))[optimal.pk]
  
  ## Homotypic doublet proportion estimate
  annotations <- tail.sample@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations) 
  nExp.poi <- round(optimal.pk * nrow(tail.sample@meta.data)) ## Assuming 7.5% doublet formation rate - tailor for your dataset
  nExp.poi.adj <- round(nExp.poi * (1 - homotypic.prop))
  
  # run DoubletFinder
  tail.sample <- doubletFinder(seu = tail.sample, 
                                   PCs = 1:min.pc, 
                                   pK = optimal.pk,
                                   nExp = nExp.poi.adj)
  metadata <- tail.sample@meta.data
  metadata
  colnames(metadata)[9] <- "doublet_finder"
  tail.sample@meta.data$doublet_finder <- metadata 
  
  ## save
  tail_post.split[[i]] <- tail.sample
}

# AFTER ensuring everything processed cleanly, remove extraneous information
#rm(bcmvn, bcmvn.max, metadata, sweep.list, sweep.stats, tail.sample, tail.singlets, tail_post.split)

# Reformat
tail_post.split[[1]]@meta.data$doublet_finder <- tail_post.split[[1]]@meta.data$DF.classification
tail_post.split[[2]]@meta.data$doublet_finder <- tail_post.split[[2]]@meta.data$DF.classification
tail_post.split[[3]]@meta.data$doublet_finder <- tail_post.split[[3]]@meta.data$DF.classification
tail_post.split[[4]]@meta.data$doublet_finder <- tail_post.split[[4]]@meta.data$DF.classification
tail_post.split[[5]]@meta.data$doublet_finder <- tail_post.split[[5]]@meta.data$DF.classification
tail_post.split[[6]]@meta.data$doublet_finder <- tail_post.split[[6]]@meta.data$DF.classification
tail_post.split[[7]]@meta.data$doublet_finder <- tail_post.split[[7]]@meta.data$DF.classification
tail_post.split[[8]]@meta.data$doublet_finder <- tail_post.split[[8]]@meta.data$DF.classification

# Merge the identifying columns
tail.singlets <- merge(x = tail_post.split[[1]],
                       y = c(tail_post.split[[2]], tail_post.split[[3]], tail_post.split[[4]],
                             tail_post.split[[5]], tail_post.split[[6]], tail_post.split[[7]],
                             tail_post.split[[8]]),
                       project = "tail scRNAseq")

# Merge into the tail dataset so we hae a column labeled doublet_finder with either "Doublet" or "Singlet"
tail@meta.data$doublet_finder <- tail.singlets@meta.data$doublet_finder

# Check to make sure labels are transferred
VlnPlot(tail, features = c("percent.rp"), ncol = 1, group.by =  "doublet_finder", pt.size = 1)
VlnPlot(tail, features = c("nFeature_RNA"), ncol = 1, group.by =  "doublet_finder", pt.size = 1)
tail

saveRDS(tail, file = "../tail_preScale.rds")

# To reload
#tail <- LoadSeuratRds(file = "C:/Users/sprou/tail_preScale.rds")

```

# Normalize and Scale, regressing by Sample and nFeature_RNA
```{r}
tail_scale <- NormalizeData(tail)
tail_scale <- ScaleData(tail_scale, vars.to.regress = c("Sample", "nFeature_RNA"))
tail_scale <- FindVariableFeatures(tail_scale, selection.method = "vst", nfeatures = 2000)
tail_scale <- RunPCA(tail_scale, features = VariableFeatures(object = tail))
tail_scale <- FindNeighbors(tail_scale, dims=1:50, reduction = "pca")
tail_scale <- FindClusters(tail_scale, resolution = 2)
tail_scale <- RunUMAP(tail_scale, dims = 1:50)
DimPlot(tail_scale, group.by = "Sample")
```

# Integrate it so that the Samples don't batch separately as much!
```{r}
# Change rStudio settings so I can run this
options(future.globals.maxSize = 1024^4)

# Integrate by Sample
tail_int <- tail_scale
tail_int[["RNA"]] <- split(tail_int[["RNA"]], f = tail_int$Sample)
tail_int <- IntegrateLayers(object = tail_int, method = RPCAIntegration, orig.reduction = "pca", new.reduction = "integrated.rpca", verbose = FALSE)
tail_int[["RNA"]] <- JoinLayers(tail_int[["RNA"]])

# Process
tail_int <- FindNeighbors(tail_int, dims=1:50, reduction = "integrated.rpca")
tail_int <- FindClusters(tail_int, resolution = 2)
tail_int <- RunUMAP(tail_int, dims = 1:50, reduction = "integrated.rpca")

# Visualize
DimPlot(tail_int, reduction = "umap", group.by = "Sample")
DimPlot(tail_int, reduction = "umap", split.by = "Sample")
```

# When I'm making this file (7/10), troubleshooting showed that it actually accentuates the clustering shadowing we see with nCount, so Instead I'm sticking with the above code of Scaling and integrating! This is how you would run it if you were to do SCTransform:
```{r} 
## DON'T RUN, BUT IF YOU WERE TO THIS IS THE CODE!
# Preprocess
tail_sct <- SCTransform(tail)
tail_sct <- RunPCA(tail_sct)
tail_sct <- RunUMAP(tail_sct, dims = 1:30)

# Do we need integration?
DimPlot(tail_sct, reduction = "umap", group.by = "Sample")
# yes

# Integrate using RPCA, which is one of the most sensitive ways
tail_sct <- IntegrateLayers(
  object = tail_sct, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.rpca", normalization.method = "SCT",
  verbose = FALSE)

# Rejoin all the Samples
tail_sct[["RNA"]] <- JoinLayers(tail_sct[["RNA"]])

tail_sct@reductions

tail_sct <- FindNeighbors(tail_sct, reduction = "integrated.rpca", dims = 1:50)
tail_sct <- FindClusters(tail_sct, resolution = 2, cluster.name = "rpca_clusters")
tail_sct <- RunUMAP(tail_sct, reduction = "integrated.rpca", dims = 1:50, reduction.name = "umap.rpca")

# Visualize
tail_sct <- FindNeighbors(tail_sct, reduction = "rpca", dims = 1:50)
tail_sct <- FindClusters(tail_sct, resolution = 1)
tail_sct <- RunUMAP(tail_sct, dims = 1:50)
DimPlot(tail_sct, reduction = "rpca", group.by = "Sample")
```

# Adding in sample levels and resaving as "tail"
```{r}
tail_int@meta.data$Sample <- factor(tail_int@meta.data$Sample, levels = c("un0dpa", "un1dpa", "un3dpa", "un7dpa", "0dpa", "1dpa", "3dpa", "7dpa"))
tail <- tail_int
```

# Load previously identified monocle cell types- this was useful when adding annotations
```{r}
monocle_tail <- load_monocle_objects("/Users/averyswearer/Desktop/Avery_sc/AAS/tail_initialAnnotations_2025-05-05.cdsObject")

cell_types <- colData(monocle_tail)$prelim_cell_type
cell_types <- data.frame(cell_types)
rownames(cell_types) <- rownames(colData(monocle_tail))
tail <- AddMetaData(object = tail, metadata = cell_types)
```

# After doing some clustering in the other files, it looks like there are a couple of clusters that are only low count unidentifiable cells
```{r}
# You can see this by looking at nFeature_RNA
tail@meta.data$nFeat_good <- ifelse(tail@meta.data$nFeature_RNA > 500, "Good", "Not Good")
DimPlot(tail, group.by = "nFeat_good")

# Went back to subsetting and changed it to 500 and 800, but I lose a lot of information. LuLu Callies suggested just taking out the bad clusters, so let's try that!

DimPlot(tail, group.by = "seurat_clusters")
tail_no0 <- subset(x = tail, subset = (seurat_clusters != "0"))

tail_no0@meta.data$nFeat_good <- ifelse(tail_no0@meta.data$nFeature_RNA > 500, "Good", "Not Good")
DimPlot(tail_no0, group.by = "nFeat_good")
DimPlot(tail_no0, group.by = "seurat_clusters", label = TRUE)

tail_no0 <- subset(x = tail_no0, subset = (seurat_clusters != "38"))
tail_no0 <- subset(x = tail_no0, subset = (seurat_clusters != "16"))

#making sure that I can take out the poor quality neural cluster without losing other cells
only <- subset(x = tail_no0, subset = (seurat_clusters == "16"))
DimPlot(only, group.by = "nFeat_good")
DimPlot(only, group.by = "seurat_clusters", label = TRUE)
tail_no0 <- FindClusters(tail_no0, resolution = 4, cluster.name = "rpca_clusters")
tail_no0 <- RunUMAP(tail_no0, reduction = "integrated.rpca", dims = 1:40, reduction.name = "umap.rpca")
```

# Final grouping is with tail_no0, i.e. the dataset with a 200 feature filter but with a few poor quality clusters taken out
```{r}
tail_scale <- NormalizeData(tail_no0)
tail_scale <- ScaleData(tail_scale, vars.to.regress = c("Sample", "nFeature_RNA"))
tail_scale <- FindVariableFeatures(tail_scale, selection.method = "vst", nfeatures = 2000)
tail_scale <- RunPCA(tail_scale, features = VariableFeatures(object = tail_no0))

# Run to visualize how this change affects grouping

#tail_scale <- FindNeighbors(tail_scale, dims=1:50, reduction = "pca")
#tail_scale <- FindClusters(tail_scale, resolution = 2)
#tail_scale <- RunUMAP(tail_scale, dims = 1:50)
#DimPlot(tail_scale, group.by = "Sample")
```
# Post no0-> no one grouping or cluster with low quality = success!

# Integrate it so that the Samples don't batch separately as much!
```{r}
# Integrate by Sample
tail_int <- tail_scale
tail_int[["RNA"]] <- split(tail_int[["RNA"]], f = tail_int$Sample)
tail_int <- IntegrateLayers(object = tail_int, method = RPCAIntegration, orig.reduction = "pca", new.reduction = "integrated.rpca", verbose = FALSE)
tail_int[["RNA"]] <- JoinLayers(tail_int[["RNA"]])

# Process
tail_int <- FindNeighbors(tail_int, dims=1:50, reduction = "integrated.rpca")
tail_int <- FindClusters(tail_int, resolution = 2)
tail_int <- RunUMAP(tail_int, dims = 1:50, reduction = "integrated.rpca")

# Visualize
DimPlot(tail_int, reduction = "umap", group.by = "Sample")
DimPlot(tail_int, reduction = "umap", split.by = "Sample")

# Test to double check cell quality again
tail_int@meta.data$nFeat_good <- ifelse(tail_int@meta.data$nFeature_RNA > 500, "Good", "Not Good")
DimPlot(tail_int, group.by = "nFeat_good")
```

Andrea doesn't like that the neural clusters are separate, so let's try to preserve that
```{r}
# Changing the seed- okay yay this looks good!
tail <- RunUMAP(tail, reduction = "integrated.rpca", dims = 1:50, reduction.name = "umap.rpca", seed.use = 13)

DimPlot(tail, group.by = "seurat_clusters", reduction = "umap.rpca")
DimPlot(tail, group.by = "seurat_cell_types", reduction = "umap.rpca")
```

# Making sure everything looks like it should based on some markers
```{r}
FeaturePlot(tail, reduction = "umap.rpca", features = c("epyc", "not", "shh", "foxp1"))
FeaturePlot(tail, reduction = "umap.rpca",  features = c("gldn", "sox10", "pax3", "krt8.1"))
FeaturePlot(tail, reduction = "umap.rpca",  features = c("myh6", "actc1", "tbx6"))
FeaturePlot(tail, reduction = "umap.rpca",  features = c("SCX", "PAX7", "foxc1", "pax1"))
FeaturePlot(tail, reduction = "umap.rpca",  features = c("MYOD1", "myf6", "myog", "pax3", "myf5", "PAX7"))
FeaturePlot(tail, reduction = "umap.rpca",  features = c("sox2", "kcnb2", "pax6"))

tail[[]]
```

# save!
```{r}
saveRDS(tail, file = "../tail_final.rds")
```
